---
title: "Generate data from a simple genetic mixture model"
author: "Matthew Stephens"
date: "2020-07-22"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

## Introduction

This vignette is an "ice-breaker", to motivate learning
and statistical inference centered around genetic mixtures.

You don't need to know what a mixture model is to understand this,
but if you want to know more about mixture models in general you might read
this [introduction to mixture models](intro_to_mixture_models.html).

## Simulating haploid data for a single population

First we consider simulating genotype data for $n$ 
haploid individuals at $R$ independent bi-allelic loci (positions along the genome) sampled from a population. 

The term "haploid" means that each individual
has only one copy of their genome. (Most animals, are diploid, which means they have two copies of their genome -- one inherited from the mother and the other inherited from the father. However, focussing on haploid individuals makes the ideas and code easier to follow. Once you understand the haploid
case it is not too hard to extend the ideas to the diploid case.)

The term "bi-allelic" means that the loci have two possible alleles (types),
which for convenience we will label `0` and `1`. 

Under these assumptions, 
the genotype for each individual is
simply a sequence of 0s and 1s.
The probability of seeing a `0` vs a `1` at each locus is determined by the "allele frequencies" at each locus, which we will specify by a vector `p`. Specifically, `p[r]` specifies the
frequency of the `1` allele at locus `r`. 

The following code simulates from this model. 
```{r}
#' @param n number of samples
#' @param p a vector of allele frequencies
r_haploid_genotypes = function(n,p){
  R = length(p)
  x = matrix(nrow = n, ncol=R)
  for(i in 1:n){
    x[i,] = rbinom(R,rep(1,R),p)
  }
  return(x)
}
```

### Example

To illustrate this function
we simulate a small example dataset, containing 20 individuals at 9 loci.
The frequencies of the `1` allele at the loci are increasing from 0.1 at
the first locus to 0.9 at the 9th locus (the pattern is not supposed to be realistic, it is just to help illustrate the idea).

As you can see, the `1` allele is rarer at the earlier loci, whereas the `0` allele is rarer at the later loci.

```{r}
set.seed(123)
p = seq(0.1,0.9,length=9)
x = r_haploid_genotypes(20,p)
p
x 
```


## Simulating haploid data from a mixture of two populations

Now suppose we sample from a group of individuals formed by
mixing together the individuals from two different populations.
This is an example of a "mixture model".

For simplicity we will assume the two different populations
are mixed in equal proportions. That is the "mixture proportions"
are 0.5 and 0.5.

The following `r_simplemix` function generates data from such a model.
The allele frequencies for the two populations must be specified in a matrix `P` whose first row contains the allele frequencies for population `1` and 
second row is the allele frequencies for population `2`. (So element
`P[k,r]` is the
frequency of the `1` alleles in population `k` at locus `r`.)
For each individual `i` it randomly samples the population (`z[i]`) to be
1 or 2, and then uses the `r_haploid_genotypes` to generate the genotypes
(`x[i,]`) from that population. 


```{r}
#' @param n number of samples
#' @param P a 2 by R matrix of allele frequencies
r_simplemix = function(n,P){
  R = ncol(P) # number of loci
  z = rep(0,n) # used to store population of origin of each individual
  x = matrix(nrow = n, ncol=R) #used to store genotypes
  
  for(i in 1:n){
    z[i] = sample(1:2, size=1, prob=c(0.5,0.5))
    x[i,] = r_haploid_genotypes(1,P[z[i],])
  }
  return(list(x=x,z=z))
}
```


### Example

Here we sample 20 individuals: in one population the frequencies are as above,
whereas in the second population they are reversed (`1-p`)...again not at all realistic
but to help illustrate an idea. 

```{r}
set.seed(123)
P = rbind(p,1-p)
print(P)
sim = r_simplemix(n=20,P)
```

Here are the results of the simulation (first column is the population of origin; the remaining columns are the genotypes).
If you look carefully you should see that individuals from population 1
tend to have more `1` alleles in the later loci, whereas individuals from population `2` tend to have more `1` alleles in the earlier loci. This is because
of the way that the allele frequencies were set up in the two populations.
(Of course in real data the differences between different populations will
 not usually show patterns like this! I chose the patterns so you can
 see them by eye, not to be realistic.)

```{r}
print(cbind(z=sim$z,sim$x))
```


## Inference problems

These types of data can help motivate a number of statistical inference problems.
 
1. Given the allele frequencies `P` and the genotypes `x`, how might
you infer the populations of origin `z`? In the genetic literature this
is sometimes called the "assignment problem"; more generally, it is an 
example of a "classification problem". 

2. Given the populations of origin `z` and the genotypes `x`, how
might you infer the population allele frequencies `P`?

3. Given just the genotypes `x` how might you infer both `z` and `P`? (This is an example of a "clustering" problem). 

## Exercises

Here are some things you might like to try:

1. Modify the `r_simplemix` code to allow the mixture proportions to be specified, rather than fixed at (0.5,0.5). You could do this by adding a parameter `w` to the function that specifies the proportions to use (`w` for "weights").

2. Write a function, `posterior_prob_assignment=function(x,P,w)`, to compute the posterior probability that each individual came from each population, given the genotypes 
`x`,  the allele frequencies `P` and the mixture proportions `w`.  Apply your function to the simulated data.

3. Write a function `posterior_param_allele_frequencies=function(x,z,a)` to compute the parameters of the beta posterior in each population at each locus.
Here `a` is a vector of length 2 giving the parameters of the beta prior for `P[k,r]`. 
That is, the prior is `P[k,r]` $\sim$ Beta(`a[1]`,`a[2]`).
Because the Beta distribution has two parameters, there will be 2 parameters for each locus and each population. So the output of your function should be a 2 x 'K' x `R` array (where 'K=2' because we have a mixture of 2 populations).



## Answers

Here are some answers to the above exercises.

### Exercise 1

```{r}
#' @param n number of samples
#' @param P a 2 by R matrix of allele frequencies
#' @param w a w-vector of component prior probabilities
r_simplemix = function(n,P,w=c(0.5,0.5)){
  R = ncol(P) # number of loci
  z = rep(0,n) # used to store population of origin of each individual
  x = matrix(nrow = n, ncol=R) #used to store genotypes
  
  for(i in 1:n){
    z[i] = sample(1:2, size=1, prob=w)
    x[i,] = r_haploid_genotypes(1,P[z[i],])
  }
  return(list(x=x,z=z))
}
```


### Exercise 2


```{r}
#' Compute the likelihood for allele frequences p given genotype data x
#' @param p an R vector of allele frequencies
#' @param x an R vector of genotypes
likelihood = function(p,x){
  return(prod(p^x*(1-p)^(1-x)))
}

#' normalize a vector, x, so it's elements sum to 1
#' @param x a vector
normalize = function(x){x/sum(x)}

#' Compute posterior assignment probabilities
#' @param x an n by R matrix of genotypes
#' @param P a 2 by R matrix of allele frequencies
#' @param w a 2-vector of prior probabilities
posterior_prob_assignment=function(x,P,w){
  n = nrow(x)
  K = length(w)
  post = matrix(nrow=n, ncol=K) # to store the posterior probabilities
  lik = rep(0,K) # a vector to store the likelihoods
  for(i in 1:n){
    for(k in 1:K){
      lik[k] = likelihood(P[k,],x[i,])
    }
    post[i,] = normalize(lik*w)
  }
  return(post)
}
```


Here we can run this on the example data, and compare the posterior probabilities with the true labels.
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)
posterior = posterior_prob_assignment(sim$x,P,w=c(0.5,0.5))
plot(sim$z,posterior[,2],xlab="true population", ylab="posterior prob for population 2")
```


### Exercise 3


```{r}
#' Compute the posterior parameters for allele frequencies given genotypes 
#' and population labels
#' @param x an n by R matrix of genotypes
#' @param z an n vector of population assignments
#' @param a a 2-vector of prior parameters
posterior_param_allele_frequencies=function(x,z,a){
 K = 2
 R = ncol(x)
 post_param = array(dim=c(2,K,R))
 for(k in 1:K){
   for(r in 1:R){
     number_of_ones = sum(x[z==k,r]) #number of 1s observed at locus r in population k
     total = sum(z==k) # how many individuals in population k
     post_param[,k,r] = a + c(number_of_ones, total - number_of_ones)
   }
 }
 return(post_param)
}
```

Here we can run this on the example data:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)
posterior_param = posterior_param_allele_frequencies(sim$x,sim$z,a = c(1,1))
posterior_param[,1,] # these should be the posterior parameters for population 1
posterior_param[,2,] # these should be the posterior parameters for population 2
```


# Tuesday afternoon exercises:

## Task 1. `newZ_gibbs()`

```{r}
#' Simulate new values for the population assignments from their full conditional distribution
#' @param x an n by R matrix of genotypes
#' @param P a 2 by R matrix of allele frequencies
#' @param w a 2-vector of prior probabilities
newZ_gibbs <- function(x, P, w) {
    K <- nrow(P)
    n <- nrow(x)
    
    # get the full conditionals
    zprobs <- posterior_prob_assignment(x, P, w)  # makes a matrix of probabilities
    
    newZ <- rep(NA, n)
    
    for (i in 1:n) {
      newZ[i] <- sample(1:K, size = 1, prob = zprobs[i,])   # simulate new Z's from the zprobs
    }
    
    newZ
}
```


Here we can run this on the example data:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)
newZ <- newZ_gibbs(sim$x, P, w = c(0.5, 0.5))

# here is the original value
sim$z
# here is the new value
newZ
```

## Task 2. `newP_gibbs()`

```{r}
#' Simulate new values for the allele frequencies 
#' @param x an n by R matrix of genotypes
#' @param z an n vector of population assignments
#' @param a a 2-vector of prior parameters
newP_gibbs <- function(x,z,a = c(1,1)) {
  
  # compute the beta parameters for the full conditionals of P
  p_params <- posterior_param_allele_frequencies(x, z, a)
  
  R <- ncol(x)  # number of loci
  K <- 2

  # prepare a matrix for output
  newP <- matrix(nrow = 2, ncol = R)
  
  # simulate beta random variables to fill the P matrix
  for(r in 1:R) {
    for(k in 1:K) {
    
    # get the beta parameters for population k
    par1 <- p_params[1,k,r]
    par2 <- p_params[2,k,r]
    
    # simulate a new value from a beta distribution
    newP[k,r] <- rbeta(1, par1, par2)
    }
  }
  
  newP
}
```


Here we can run this on the example data:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)
newP <- newP_gibbs(sim$x, sim$z, a = c(1,1))

# here is the original value
P
# here is the new value
newP
```



## Task 3. 

```{r}
# do mcmc by Gibbs sampling for Z and P
#' @param x an n by R matrix of genotypes
#' @param a a 2-vector of prior parameters for the allele frequencies
#' @param w a 2-vector of mixing proportions assumed to be (0.5, 0.5)
#' @param nIter the number of sweeps (updates of both Z and P) of the chain to perform
mcmc_gibbs_Z_and_P <- function(
  x, 
  a = c(1, 1), 
  w=c(0.5, 0.5), 
  nIter = 500
) {
  
  n <- nrow(x)
  R <- ncol(x)
  K <- 2
  
  # we need to have an initial value for the Z's.  Just sample it, randomly from w
  z <- sample(1:2, size = n, replace = TRUE, prob = w)
  
  # cycle over the sweeps
  for (rep in 1:nIter) {
    
    # Gibbs update for P
    P <- newP_gibbs(x, z, a)
    
    # Gibbs update for z
    z <- newZ_gibbs(x, P, w)
    
    # For now, just print the current values
    # print z
    print(paste("Z: rep =", rep))
    print(z)
    
    # print P
    print(paste("P: rep =", rep))
    print(P)
  }
}
```



Here we can run this on the example data:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)

# now, given only the genotypes x, the allele frequency prior parameters a,
# and assuming mixing proportions of w = c(0.5, 0.5), we can run a Markov chain
# that samples from the posterior distribution of Z, and P.

# Print the true values of z and P from the simulated data:
sim$z
P

# Currently, the function just prints the values of Z and P each iteration.
# Just run it for 10 iterations
mcmc_gibbs_Z_and_P(sim$x, nIter = 10)
```


Go back and notice that the initial `Z` does not look anything like the true value
from the simulation, but, after only 10 iterations, Z in the Markov chain is quite
similar to the true Z.


## Task 4: `newW_gibbs()`

```{r}
#' Simulate new values for the component proportions 
#' @param z an n vector of population assignments
#' @param b a 2-vector of prior parameters
newW_gibbs <- function(z,b = c(1,1)) {
  n1 = sum(z==1)
  n2 = sum(z==2)
  w = rbeta(1,shape1 = b[1]+n1, shape2 = b[2]+n2)
  return(c(w,1-w))
}
```

```{r}
# do mcmc by Gibbs sampling for Z and P and W
#' @param x an n by R matrix of genotypes
#' @param a a 2-vector of prior parameters for the allele frequencies
#' @param b a 2-vector of prior parameters for the mixing proportions
#' @param nIter the number of sweeps (updates of both Z and P) of the chain to perform
mcmc_gibbs_Z_and_P_and_W <- function(
  x, 
  a = c(1, 1), 
  b = c(1, 1), 
  nIter = 500
) {
  
  n <- nrow(x)
  R <- ncol(x)
  K <- 2
  
  # initialize w
  w <- c(0.5,0.5)
  
  # we need to have an initial value for the Z's.  Just sample it, randomly from w
  z <- sample(1:2, size = n, replace = TRUE, prob = w)
  
  # store z every iteration for final output
  z_trace <- matrix(NA,nrow=nIter, ncol=n)
  
  # cycle over the sweeps
  for (rep in 1:nIter) {
    
    # Gibbs update for P
    P <- newP_gibbs(x, z, a)
    
    # Gibbs update for z
    z <- newZ_gibbs(x, P, w)
    
    # Gibbs update for z
    w <- newW_gibbs(z, b)
    
    # store z
    z_trace[rep,] = z
    
  }
  return(list(P=P,z=z,w=w, z_trace = z_trace))
}
```

Here we can run this on the example data:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)

# now, given only the genotypes x, the allele frequency prior parameters a,
# and assuming mixing proportions of w = c(0.5, 0.5), we can run a Markov chain
# that samples from the posterior distribution of Z, and P.

# Print the true values of z and P from the simulated data:
sim$z
P

# Just run it for 10 iterations
res = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 10)
res$z
res$w

# When I ran 10 iterations it was not enough... so I tried 100
res = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 100)
res$z
res$w
table(res$z,sim$z) # note the label-switching....
```

Rather than just taking the final result, we should really average over the iterations.
And do a longer run. Here I plot the trace of the MCMC for individual 1, and I comupute
for each individual the posterior mode of its assigment (1 or 2). The posterior mode\ assignments in this case turn out to be exactly correct.
```{r}
res = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 1000)
plot(res$z_trace[,1], main="trace of assignments of individual 1")
post_assignment_prob_pop2 <- colMeans(res$z_trace==2)
post_mode_z = 1+ (post_assignment_prob_pop2>0.5)
table(post_mode_z,sim$z)
```

## Adding a function to trace the log-target value

When we are running MCMC we should always monitor its convergence somehow.
It is really useful to do this by computing $\log \pi(x)$ where $\pi$ is the target
distribution. This is useful because even if $x$ is very high dimensional 
$\log \pi(x)$ is just a one-dimensional real number. 

These functions compute the value of $\log p(x,z,P,w | a,b)$.

```{r}
#' @param x an R vector of data (single genotype)
#' @param p an R vector of allele frequencies
#' @return the log-likelihood for a single individual given the allele frequencies in its population
log_pr_x_given_p = function(x,p){
  return(sum(x*log(p)+(1-x)*log(1-p)))
}


# Compute the log of the target distribution p(x,z,P,w | a,b)
#' @param x an n by R matrix of genotypes
#' @param z an n vector of population assignments
#' @param P a 2 by R matrix of allele frequencies
#' @param w a 2-vector of population proportions
#' @param a a 2-vector of prior parameters for the allele frequencies
#' @param b a 2-vector of prior parameters for the mixing proportions
log_pi = function(x,z,P,w,a,b){
  n = nrow(x)
 
  log_prior_z = sum(ifelse(z==1, log(w[1]), log(w[2])))
  log_prior_P = sum(dbeta(P,shape1=a[1], shape2=a[2],log=TRUE))
  log_prior_w = dbeta(w[1],b[1],b[2])
  
  # now compute the term log Pr(x | z,P) by summing over individuals
  loglik = 0
  for(i in 1:n){
    loglik = loglik + log_pr_x_given_p(x[i,],P[z[i],])
  }
  
  return(loglik+log_prior_z+log_prior_P+log_prior_w)
}
```


Now incorporate that trace into the function

```{r}
# do mcmc by Gibbs sampling for Z and P and W
#' @param x an n by R matrix of genotypes
#' @param a a 2-vector of prior parameters for the allele frequencies
#' @param b a 2-vector of prior parameters for the mixing proportions
#' @param nIter the number of sweeps (updates of both Z and P) of the chain to perform
mcmc_gibbs_Z_and_P_and_W <- function(
  x, 
  a = c(1, 1), 
  b = c(1, 1), 
  nIter = 500
) {
  
  n <- nrow(x)
  R <- ncol(x)
  K <- 2
  
  # initialize w
  w <- c(0.5,0.5)
  
  # we need to have an initial value for the Z's.  Just sample it, randomly from w
  z <- sample(1:2, size = n, replace = TRUE, prob = w)
  
  # store z every iteration for final output
  z_trace <- matrix(NA,nrow=nIter, ncol=n)
  
  log_pi_trace <- rep(NA,nIter)
  
  # cycle over the sweeps
  for (rep in 1:nIter) {
    
    # Gibbs update for P
    P <- newP_gibbs(x, z, a)
    
    # Gibbs update for z
    z <- newZ_gibbs(x, P, w)
    
    # Gibbs update for z
    w <- newW_gibbs(z, b)
    
    # store z
    z_trace[rep,] = z
    log_pi_trace[rep] = log_pi(x,z,P,w,a,b)
  }
  return(list(P=P,z=z,w=w, z_trace = z_trace, log_pi_trace=log_pi_trace))
}
```

Here we can run this on the example data. We run it 3 times and compare results:
```{r}
set.seed(123)
sim = r_simplemix(n=20,P)
res1 = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 1000)
res2 = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 1000)
res3 = mcmc_gibbs_Z_and_P_and_W(sim$x, nIter = 1000)
plot(res1$log_pi_trace, ylab="log p(x,P,z,w)", type="l",col="black")
lines(res2$log_pi_trace,col="red")
lines(res3$log_pi_trace,col="green")
```
\